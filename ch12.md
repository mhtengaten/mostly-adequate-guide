# Chapter 11: Traversing the Stone

So far, in our cirque du conteneur, you've seen us tame the ferocious [functor](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch8.md#my-first-functor), bending it to our will to perform any operation that strikes our fancy. You've been dazzled by the juggling of many dangerous effects at once using function [application](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch10.md) to collect the results. Sat there in amazement as containers vanished in thin air by [joining](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch9.md) them together. At the side effect sideshow, we've seen them [composed](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch8.md#a-spot-of-theory) into one. And most recently, we've ventured into the supernatural and [transformed](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch11.md) a type into another one before your very eyes.

And now for our next trick, we'll look at *Traversals*. We'll watch types soar over one another like trapeze artists holding our value in tact. We'll reorder effects like they were cars in a tilt-a-whirl. When our containers get intertwined like the limbs of a contortionist, we can use this to straighten things out. We'll achieve different results with different orderings. Fetch me my pantaloons and slide whistle, let's get started.

## Types n' types

Let's feel some pain.

```js
 // readFile :: FileName -> Task Error String

 // less :: FileName -> Task Error String
const less = compose(map(compose(join('\n'), take(2), split('\n')), readFile)

map(less, files)
// [Task('hail the monarchy'), Task('smash the patriarchy')]
```

Here we read a bunch of files and end up with a useless array of tasks. How might we fork each one of these? It would be most agreeable if we could switch the types around to have `Task Error [String]` instead of `[Task Error String]`. That way, we'd have one future value holding all the results, which is much more amendable to our async needs than several future values arriving at their leisure.

Here's another one:

```js
// getAttribute :: String -> Node -> Maybe String
// $ :: Selector -> IO (Maybe Node)

 // getControlNode :: IO (Maybe (IO (Maybe Node)))
const getControlNode = compose(map($), map(chain(getAttribute('aria-controls'))), $)
```

Look at those `IO`s and `Maybe`s longing to be together. It'd be just lovely to `join` each of them, let them dance cheek to cheek, but alas a type stands between them like a chaperone at prom. Our best move here would be to shift their positions next to one another, that way they can be together at last and our type down can be simplified to `IO (Maybe Node)`.

We've seen how *natural transformations* can help, but there is another way and it is called *Traversable*.

## Type Feng Shui

The *Traversable* interface, which consists of two glorious functions: `sequence` and `traverse`.

Let's rearrange our types using `sequence`:

```js
sequence(Array, Just(['the facts'])) // [Just('the facts')]
sequence(Task.of, Map({a: Task.of(1), b: Task.of(2)})) // Task(Map({a: 1, b: 2}))
sequence(IO.of, Right(IO.of('buckle my shoe'))) // IO(Right('buckle my shoe'))
sequence(Either.of, [Right('wing')]) // Right(['wing'])
sequence(Task.of, Left('wing')) // Task(Left('wing'))
sequence(Array, Nothing) // [Nothing]
```

See what has happened here? Our nested type gets turned inside out like a pair of leather trousers on a humid summer night. The inner functor is shifted to the outside and vice versa. It should be known that `sequence` is bit particular about its arguments. It's type signature looks like this:

```js
// sequence :: (Traversable t, Applicative f) => (a -> f a) -> t (f a) -> f (t a)
const sequence = (point, x) => x.sequence(point)
```

Let's start with the second, and primary argument. It must be a *Traversable* holding an applicative, which sounds quite restrictive, but just so happens to be the case more often than not. That first argument there is merely a nuisance and only necessary in an untyped language. It is a type constructor (our *point*) provided so that we can invert map-reluctant types like `Left` and `Nothing` - more on that in a minute.

Using `sequence`, we can shift types around with the precision of a sidewalk thimblerigger. But how does it work? Let's look at how a type, say `Either`, would implement it:

```js
Right.prototype.sequence = function(point) {
  return this.__value.map(Right)
}
```

Ah yes, if our `__value` is a functor (it must be an applicative, in fact), we can simply `map` our constructor to leap frog the type.

You may have noticed that we've ignored the `point` entirely. It is passed in for the occasion where mapping is futile, as is the case with `Left`:

```js
Left.prototype.sequence = function(point) {
  return point(this)
}
```

In a language with a type system, the outer type can be inferred from the signature and does not need to be passed in.

## Effect assortment

Different orders have different outcomes where our containers are concerned. If I have `[Maybe a]`, that's a collection of possible values whereas if I have a `Maybe [a]`, that's a possible collection of values. In practice, the former indicates we'll be forgiving and keep "the good ones", while the latter means it's an "all or nothing" type of situation. Likewise, `Either Error (Task Error a)` could represent a client side validation and `Task Error (Either Error a)` could be a server side one. This can be applied and manipulated to give us different effects.

```js
// fromPredicate :: (a -> Bool) -> Either a a
const fromPredicate = curry((predicate, x) => predicate(x) ? Right(x) : Left(x))

// partition :: (a -> Bool) -> [a] -> [Either a a]
const partition = f => map(fromPredicate(f))

// validate :: (a -> Bool) -> [a] -> Either a [a]
const validate = f => traverse(Either.of, fromPredicate(f))
```

Here we have two different functions based on if we `map` or `traverse`.  The first, `partition` will give us an array of `Left`s and `Right`s according to the predicate function. This is useful to keep precious data around for future use rather than filtering it out with the bathwater. `validate` instead will only move forward if everything is just so.

## Law and order

Well now, before you get all judgemental and bang the backspace button like a gavel to retreat from the chapter, take a moment to recognize that these laws are useful code guarantees. I conjecture the goal of any program architecture is an attempt to place useful restrictions on our code to narrow the possibilities, to guide us into the answers as designers and readers.

An interface without laws is merely indirection. Like any other mathematical structure, we must expose properties for our own sanity. This has the same effect as encapsulation as it enables us to swap out the interface with another law abiding citizen.

Come along now, we've got some laws to suss out.

### Identity

```js
const identity1 = compose(sequence(Identity.of), map(Identity.of))
const identity2 = Identity.of

// test it out with Right
identity1(Right('stuff'))
// Identity(Right('stuff'))

identity2(Right('stuff'))
// Identity(Right('stuff'))
```

This should be straight forward. If we place an `Identity` in our functor, then turn it inside out with `sequence` that's the same as just placing it on the outside to begin with. We chose `Right` as our guinea pig as it is easy to inspect.

The use of a concrete functor here, namely `Identity` in the law itself might raise some eyebrows. Remember a [category](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch5.md#category-theory) is defined by morphisms between its objects that have associative composition and identity. When dealing with the category of functors, natural transformations are the morphisms and `Identity` is, well identity. The `Identity` functor is as fundamental in demonstrating laws as our `compose` function. In fact, we should give up the ghost and follow suit with our [Compose](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch8.md#a-spot-of-theory) type.

### Composition

```js
const comp1 = compose(sequence(Compose.of), map(Compose.of))
const comp2 = (point1, point2) => compose(Compose.of, map(sequence(point2)), sequence(point1))


// Test it out with some types we have lying around
comp1(Identity(Right([true])))
// Compose(Right([Id(true)]))

comp2(Right, Array)(Identity(Right([true])))
// Compose(Right([Id(true)]))
```

This law preserves composition as one would expect: if `sequence` compositions of functors, we shouldn't see any surprises. We arbitrarily chose `true`, `Right`, `Identity`, and `Array` to test it out. Libraries like [quickcheck](https://hackage.haskell.org/package/QuickCheck) or [jsverify](http://jsverify.github.io/) can help us test the law by fuzz testing the inputs.

As a natural consequence of the above law, we get the ability to fuse traversals:

```js
traverse(compose(Compose.of, map(compose(f , g)))) = compose(Compose.of, map(traverse(of, f)), traverse(of, g))
```

Which is nice.

### Naturality

```js
const natLaw1 = (point, nt) => compose(nt, sequence(p))
const natLaw2 = (point, nt) => compose(sequence(p), map(nt))

// test with a random natural transformation and our friendly Identity/Right functors.

// idToEither :: Identity a -> Either () a
const idToEither = x => Right(x.__value)

natLaw1(Right, idToEither)(Identity(Identity('barlow one')))
// Right(Identity('barlow one'))

natLaw2(Id, idToEither)(Identity(Identity('barlow one')))
// Right(Identity('barlow one'))
```

This law uses a natural transformation to ensure our structure does not fiddle with its contents or fall apart on us during traversal.


## In summary

*Traversable* is another way to 

